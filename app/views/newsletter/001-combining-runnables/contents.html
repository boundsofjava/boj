<h3><em>Background</em></h3>

<p>In Java 8, a block of code that takes no arguments and has no returning value can be assigned to a <span class="code">Runnable</span> instance straightforwardly:</p>

<div hljs hljs-no-escape hljs-language="java">
Runnable blockOfCode = () -> {
	System.out.println("Q: What was the weather like in winter of 2015?");
	System.out.println("A: It was very cold");
};
</div>

<p>Then, later in our program, we could execute this block of code by invoking the <span class="code">run()</span> method of our <span class="code">Runnable</span> instance:</p>

<div hljs hljs-no-escape hljs-language="java">
blockOfCode.run();
</div>

<p>Now, let's suppose the code resides in the <span class="code">whatWasTheWeatherLike()</span> method of the <span class="code">Winter</span> class:</p>

<div hljs hljs-no-escape hljs-language="java">
public class Winter {

	private final int year;

	public Winter(int year) {
		this.year = year;
	}

	public void whatWasTheWeatherLike() {
		System.out.printf("Q: What was the weather like in winter of %d?%n", year);
		System.out.println("A: It was very cold");
	}
}
</div>

<p>In this case, instead of using a lambda expression with an inline block of code, we could use a <em>reference to an instance method</em> of the <span class="code">Winter</span> class:</p>

<div hljs hljs-no-escape hljs-language="java">
Winter winterOf2015 = new Winter(2015);
Runnable runnable = winterOf2015::whatWasTheWeatherLike;
</div>

<p>So far so good. But, what if we wanted to assign different blocks of code to different <span class="code">Runnable</span> instances? We might want to keep references not only to the <span class="code">whatWasTheWeatherLike()</span> instance method of the <span class="code">winterOf2015</span> instance, but also to any no-arguments, <span class="code">void</span> method of any class, as well as to any inline block of code:

<div hljs hljs-no-escape hljs-language="java">
List<Runnable> runnables = new ArrayList<>();

Winter winterOf2015 = new Winter(2015);
runnables.add(winterOf2015::whatWasTheWeatherLike);

Winter winterOf2012 = new Winter(2012);
runnables.add(winterOf2012::whatWasTheWeatherLike);

runnables.add(() -> {
	System.out.println("Inline block of code");
});

// will print a blank line when executed
runnables.add(System.out::println);

// will invoke someNoArgsVoidMethod method on
// someClassInstance instance when executed
SomeClass someClassInstance = new SomeClass();
runnables.add(someClassInstance::someNoArgsVoidMethod);

// will exit the program when executed
runnables.add(() -> System.exit(0));
</div>

<p>We have stored all the <span class="code">Runnable</span> instances above in the <span class="code">runnables</span> list. To execute them, we could iterate the list and invoke the <span class="code">run()</span> method on each element:</p>

<div hljs hljs-no-escape hljs-language="java">
for (Runnable r : runnables) {
	r.run();
}
</div>

<p>Or in a one-liner:</p>

<div hljs hljs-no-escape hljs-language="java">
runnables.forEach(Runnable::run);
</div>

<p>However, this will execute the <span class="code">Runnable</span> instances <em>sequentially</em> and in the same order they were added to the list. What if we wanted to execute them in parallel, or some sequentially and some in parallel? And what if we had more than one list and wanted to execute their <span class="code">Runnable</span> elements interleaved? This is when combinators come in handy.</p>

<div class="double-spacing"></div>

<h3><em>Combinators</em></h3>

<p>There are a few definitions of combinator in the web. <a href="https://en.wikipedia.org/wiki/Combinatory_logic" target="_blank">The one I like the most</a> states that <em>&laquo;a combinator is a function that takes one or more functions as arguments and uses only function application and other combinators to define a result from its arguments&raquo;.</em></p>

<p>While the above definition is quite easy to understand for a programmer that has worked with functional constructs, I think it could be a little bit too much functional for a Java programmer coming from the imperative paradigm. On the other hand, the <span class="code">Runnable</span> interface is widely known in the Java world, so why not use it to show how useful combinators can be?</p>

<p>Before tackling combinators, let me introduce the <span class="code">Sleeper</span> enum, which I'll use in the rest of the newsletter to simulate long-running tasks:</p>

<div hljs hljs-no-escape hljs-language="java">
package com.boundsofjava.newsletter.runnablecombinator;

import java.util.concurrent.TimeUnit;
import java.util.stream.IntStream;

/**
 * Enum that simply sleeps; TWO sleeps 2 seconds, THREE sleeps 3 seconds, etc.
 */
public enum Sleeper {
    TWO(2), THREE(3), FOUR(4), FIVE(5), SIX(6), SEVEN(7);

    private final int seconds;

    private Sleeper(int seconds) {
        this.seconds = seconds;
    }

    /**
     * Sleeps the number of seconds specified by this enum's
     * seconds attribute, generating a countdown output.
     */
    public void sleep() {
        Output.message("%s => Sleeping for %d seconds...", this, seconds);
        // Countdown iteration: n, n - 1, ..., 0
        IntStream.iterate(seconds, i -> i - 1).limit(seconds).forEach(i -> {
            try {
                Output.message("%s => %d", this, i);
                TimeUnit.SECONDS.sleep(1);
            } catch (InterruptedException e) {
                // Propagate interrupt status
                Thread.currentThread().interrupt();
                Output.message("%s => Interrupted!", this);
            }
        });
        Output.message("%s => 0. Waking up...", this);
    }
}
</div>

<p>The <span class="code">Sleeper.sleep</span> method uses the <span class="code">IntStream.iterate</span> method to generate a stream of descending <span class="code">int</span> elements that are printed every one second in a countdown fashion, i.e. <span class="code">Sleeper.TWO</span> produces a <span class="code">2, 1, 0</span> countdown sequence, <span class="code">Sleeper.THREE</span> produces a <span class="code">3, 2, 1, 0</span> countdown sequence, etc. The <span class="code">Sleeper.sleep</span> method actually takes <span class="code">n</span> seconds to execute (with <span class="code">n</span> being the starting number of the countdown sequence) and gently prints the countdown sequence.</p>

<p>For printing the countdown sequence I'm using the <span class="code">Output</span> class, which simply formats the given <span class="code">String</span> before printing it:</p>

<div hljs hljs-no-escape hljs-language="java">
package com.boundsofjava.newsletter.runnablecombinator;

public final class Output {

    private Output() {
    }

    public static void highlighted(String message) {
        System.out.println("-----------------------------------------");
        System.out.println(message);
        System.out.println("-----------------------------------------");
    }

    public static void message(String message, Object... args) {
        System.out.printf(message + "%n", args);
    }
}
</div>


