<h3><em>Background</em></h3>

<p>In Java 8, a block of code that takes no arguments and has no returning value can be assigned to a <span class="code">Runnable</span> instance straightforwardly:</p>

<div hljs hljs-no-escape hljs-language="java">
Runnable blockOfCode = () -> {
    System.out.println("Q: What was the weather like in winter of 2015?");
    System.out.println("A: It was very cold");
};
</div>

<p>Then, later in our program, we could execute this block of code by invoking the <span class="code">run()</span> method of our <span class="code">Runnable</span> instance:</p>

<div hljs hljs-no-escape hljs-language="java">
blockOfCode.run();
</div>

<p>Now, let's suppose the code resides in the <span class="code">whatWasTheWeatherLike()</span> method of the <span class="code">Winter</span> class:</p>

<div hljs hljs-no-escape hljs-language="java">
public class Winter {

    private final int year;

    public Winter(int year) {
        this.year = year;
    }

    public void whatWasTheWeatherLike() {
        System.out.printf("Q: What was the weather like in winter of %d?%n", year);
        System.out.println("A: It was very cold");
    }
}
</div>

<p>In this case, instead of using a lambda expression with an inline block of code, we could use a <em>reference to an instance method</em> of the <span class="code">Winter</span> class:</p>

<div hljs hljs-no-escape hljs-language="java">
Winter winterOf2015 = new Winter(2015);
Runnable runnable = winterOf2015::whatWasTheWeatherLike;
</div>

<p>So far so good. But, what if we wanted to assign different blocks of code to different <span class="code">Runnable</span> instances? We might want to keep references not only to the <span class="code">whatWasTheWeatherLike()</span> instance method of the <span class="code">winterOf2015</span> instance, but also to any no-arguments, <span class="code">void</span> method of any class, as well as to any inline block of code:

<div hljs hljs-no-escape hljs-language="java">
List<Runnable> runnables = new ArrayList<>();

Winter winterOf2015 = new Winter(2015);
runnables.add(winterOf2015::whatWasTheWeatherLike);

Winter winterOf2012 = new Winter(2012);
runnables.add(winterOf2012::whatWasTheWeatherLike);

runnables.add(() -> {
    System.out.println("Inline block of code");
});

// will print a blank line when executed
runnables.add(System.out::println);

// will invoke someNoArgsVoidMethod method on
// someClassInstance instance when executed
SomeClass someClassInstance = new SomeClass();
runnables.add(someClassInstance::someNoArgsVoidMethod);

// will exit the program when executed
runnables.add(() -> System.exit(0));
</div>

<p>We have stored all the <span class="code">Runnable</span> instances above in the <span class="code">runnables</span> list. To execute them, we could iterate the list and invoke the <span class="code">run()</span> method on each element:</p>

<div hljs hljs-no-escape hljs-language="java">
for (Runnable r : runnables) {
    r.run();
}
</div>

<p>Or in a one-liner:</p>

<div hljs hljs-no-escape hljs-language="java">
runnables.forEach(Runnable::run);
</div>

<p>However, this will execute the <span class="code">Runnable</span> instances <em>sequentially</em> and in the same order they were added to the list. What if we wanted to execute them in parallel, or some sequentially and some in parallel? And what if we had more than one list and wanted to execute their <span class="code">Runnable</span> elements interleaved? This is when higher-order functions come in handy.</p>

<div class="separator spacing">&#10022; &#10022; &#10022;</div>

<h3><em>Higher-order functions</em></h3>

<p>The <a href="https://en.wikipedia.org/wiki/Higher-order_function" target="_blank">definition of higher-order function</a> I most like states that <em>&laquo;a higher-order function is a function that takes one or more functions as arguments and that might return a function as its result&raquo;.</em></p>

<p>While the above definition is quite easy to understand for a programmer that has worked with functional constructs, I think it could be a little bit too much functional for mainstream Java developers. On the other hand, the <span class="code">Runnable</span> interface is widely known in the Java world. So, why not use it to show how useful higher-order functions can be?</p>

<p>But before tackling higher-order functions, let's introduce the <span class="code">Sleeper</span> enum, which I'll use in the rest of this newsletter to simulate long-running tasks:</p>

<div hljs hljs-no-escape hljs-language="java">
package com.boundsofjava.newsletter.higherorderrunnable;

import java.util.concurrent.TimeUnit;
import java.util.stream.IntStream;

/**
 * Enum that simply sleeps; TWO sleeps 2 seconds, THREE sleeps 3 seconds, etc.
 */
public enum Sleeper {
    TWO(2), THREE(3), FOUR(4), FIVE(5), SIX(6), SEVEN(7);

    private final int seconds;

    private Sleeper(int seconds) {
        this.seconds = seconds;
    }

    /**
     * Sleeps the number of seconds specified by this enum's
     * seconds attribute, generating a countdown output.
     */
    public void sleep() {
        System.out.printf("%s => Sleeping for %d seconds...%n", this, seconds);
        // Countdown iteration: n, n - 1, ..., 0
        IntStream.iterate(seconds, i -> i - 1).limit(seconds).forEach(i -> {
            try {
                System.out.printf("%s => %d%n", this, i);
                TimeUnit.SECONDS.sleep(1);
            } catch (InterruptedException e) {
                // Propagate interrupt status
                Thread.currentThread().interrupt();
                System.out.printf("%s => Interrupted!%n", this);
            }
        });
        System.out.printf("%s => 0. Waking up...%n", this);
    }
}
</div>

<p>The <span class="code">Sleeper.sleep()</span> method uses the <span class="code"><a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/IntStream.html#iterate-int-java.util.function.IntUnaryOperator-" target="_blank">IntStream.iterate()</a></span> method to generate a stream of descending <span class="code">int</span> elements that are printed in a countdown fashion, i.e. <span class="code">Sleeper.TWO.sleep()</span> produces the <span class="code">2, 1, 0</span> countdown sequence, <span class="code">Sleeper.THREE.sleep()</span> produces <span class="code">3, 2, 1, 0</span>, etc. The <span class="code">Sleeper.sleep()</span> method actually takes <span class="code">n</span> seconds to execute (with <span class="code">n</span> being the starting number) and gently prints the countdown sequence.</p>

<div class="spacing"></div>

<h4><em>Introducing Higher-order Runnables</em></h4>

<p>Now, back to our higher-order stuff... We define a <em>higher-order runnable</em> as per the definition given above, except for the term <em>function</em>, which we'll change by <em>runnable</em>. Thus, according to our new, slightly modified definition, a <em>higher-order runnable</em> is <em>&laquo;a function that takes one or more <span class="code">Runnable</span> instances as arguments and that returns a <span class="code">Runnable</span> instance as its result&raquo;.</em></p>

<p>In code, we represent a <span class="code">HigherOrderRunnable</span> with the following functional interface:</p>

<div hljs hljs-no-escape hljs-language="java">
@FunctionalInterface
public interface HigherOrderRunnable {

    /**
     * Combines the given Runnables into a single Runnable.
     *
     * @param runnables Runnables to be combined
     * @return A Runnable that is the result of combining the given Runnables
     */
    Runnable combine(Runnable... runnables);
}
</div>

<p>As with every functional interface, we can implement it by means of a lambda expression:</p>

<div hljs hljs-no-escape hljs-language="java">
static HigherOrderRunnable sequential() {
    return runnables -> () -> Arrays.stream(runnables).forEach(Runnable::run);
}
</div>




